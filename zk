#!/usr/bin/env bash

# Define some variables for notes directory,
# preferred editor, and date format
NOTEDIR="$HOME/Documents/notes/"
EDITOR="nvim"
DATE_STR=$(date "+%Y-%m-%d")
TIME_STR=$(date "+%I:%M")

# **DO NOT MESS WITH THESE**
NOTEDIR=$(echo "$NOTEDIR" | sed 's:/*$::') # Sanitize $NOTEDIR; remove trailing '/'
UUID=$(uuidgen) 
TITLE=

throw_error() {
  echo $1
  exit 1
}

zk_wrap_git() {
  git -C $NOTEDIR "$@"
}

zk_git_commit() {
  grep_str=$1
  state=$2
  hostname=$(cat /etc/hostname)

  zk_wrap_git status -s | grep -e "$grep_str" | awk '{print $2}' | while read object; do
    zk_wrap_git add $object
    zk_wrap_git commit -m "$state: $object @$hostname"
  done
}

zk_auto_git() {
  zk_git_commit "??" "added"
  zk_git_commit " M" "changed"
  zk_git_commit " D" "removed"
}

populate_fields() {
  new_note=$1

  sed -i "s/<date>/$DATE_STR/g" $1
  sed -i "s/<time>/$TIME_STR/g" $1
  sed -i "s/<uuid>/$UUID/g" $1
  sed -i "s/<title>/$TITLE/g" $1
}

# TODO: refactor to allow reading initial note content from stdin
gen_from_template() {
  template_file="$NOTEDIR/.templates/${TEMPLATE:-default}.md"

  [[ ! -f $template_file ]] && throw_error "Error: no such template file '$TEMPLATE' found."

  note_generated="$NOTEDIR/$UUID.md"
  cp $template_file $note_generated 
  populate_fields $note_generated
  $EDITOR $note_generated
}

gen_daily() {
  locate_daily=$(grep -lr "# $DATE_STR" --include "*.md" $NOTEDIR)
  [[ -z $locate_daily ]] \
    && TEMPLATE="daily" \
    && gen_from_template \
    || $EDITOR $locate_daily
}

gen_notedir() {
  read -p "The path '$NOTEDIR' does not exist. Would you like to create it? \
  [y/N]" response
  case "$response" in
    [yY]) mkdir -p $NOTEDIR && echo "$NOTEDIR created.";;
    *) echo "No action taken." ;;
  esac
}

prune() {
  # TODO: implement check for if no files are found and echo message
  [[ ! $1 =~ ^[0-9]+$ ]] && throw_error "Bad Argument: '$1' is not a number."
  for file in $NOTEDIR/*; do
    [[ $(wc -w < $file) -lt $1 ]] \
      && bat $file \
      && read -p "(e)dit, (d)elete, or [Enter]continue: " choice \
      && printf "\n" \
      && case "$choice" in
        [Ee]) $EDITOR $file ;;
        [Dd]) 
          read -r -p "Are you sure? [y/N] " response
          case "$response" in
            [yY]) rm $file && echo -e "\nRemoved $file";;
            *) echo -e "\nNo action taken." ;;
          esac ;;
        *) continue ;;
      esac \
  done
}

# read_in() {
#   shift $(($OPTIND - 1))
#
#   while read line
#   do
#     # broke
#     echo $line
#   done < "${1:-/dev/stdin}"
#   echo "$INITIAL_CONTENT"
# }

usage() {
  printf "zk: glue marksman LSP and your notebook together!

USAGE:

  zk [options]

OPTIONS:
  zk -n [<-t <title> -m <template_file>]
    Generate new note; may supply a template_file name to use when generating
  zk -p <word_count>
    Search \$NOTEDIR for notes with a word count less than the supplied number
    and be prompted to edit or delete them. Helps to expand thin notes and get
    rid of empty ones.
  zk -g <git_arguments>
    Pass everything after -g directly to git inside \$NOTEDIR

Templates can contain fields to automatically populated with information, available fields are:

    <date>  | the current date
    <time>  | the current TIME_STR
    <uuid>  | uuid of note (corrosponds to file name) 
    <title> | title pass from -t

By default opening zk generates or opens the daily note; lingering, empty dailies can be cleaned up with -p
  \n" 
}

[[ ! -d "$NOTEDIR" ]] && gen_notedir

optstring="g:t:m:p:hn"

while getopts $optstring flag
do
    case "${flag}" in
        g) zk_wrap_git ${@:2} && exit 0 ;;
        t) TITLE=${OPTARG};;
        m) TEMPLATE=${OPTARG};;
    esac
done

OPTIND=1

# TODO: cover errors for illegal options
while getopts $optstring flag
do
    case "${flag}" in
        p) prune ${OPTARG} ;;
        h) usage && exit 0 ;;
        n) gen_from_template ;;
    esac
done

[[ $# = 0 ]] && gen_daily

[[ -d $NOTEDIR/.git ]] && zk_auto_git
